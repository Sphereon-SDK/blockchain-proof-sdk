<?php
/**
 * VerificationApi
 * PHP version 5
 *
 * @category Class
 * @package  Sphereon\SDK\Blockchain\Proof
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Blockchain Proof
 *
 * With the Blockchain Proof API it is easy to prove or disprove existence of data at a certain point in time. Behind the scenes it stores entries using the Factom (bitcoin), Multichain or Ethereum blockchain by means of our generic blockchain API.    The flow is generally as follows:  1. Make sure a configuration is present  2. Register content by uploading a file, some content, or providing a Stream Location from the Storage API. When you upload content you have to tell the API whether the data has already been hashed or not. If not, or when uploading a file or stream location, the API will take care of the hashing  3. Verify content by uploading a file, some content, or providing a Stream Location from the Storage API. When you upload content you have to tell the API whether the data has already been hashed or not. If not, or when uploading a file or stream location, the API will take care of the hashing. You will get back whether the content has been registered previously or not    Full API Documentation: https://docs.sphereon.com/api/blockchain-proof/0.10/html  Interactive testing: A web based test console is available in the Sphereon API Store at https://store.sphereon.com
 *
 * OpenAPI spec version: 0.10
 * Contact: dev@sphereon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Sphereon\SDK\Blockchain\Proof\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Sphereon\SDK\Blockchain\Proof\ApiException;
use Sphereon\SDK\Blockchain\Proof\Configuration;
use Sphereon\SDK\Blockchain\Proof\HeaderSelector;
use Sphereon\SDK\Blockchain\Proof\ObjectSerializer;

/**
 * VerificationApi Class Doc Comment
 *
 * @category Class
 * @package  Sphereon\SDK\Blockchain\Proof
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class VerificationApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation verifyUsingContent
     *
     * Verify content
     *
     * @param  string $config_name The configName for this operation (required)
     * @param  \Sphereon\SDK\Blockchain\Proof\Model\ContentRequest $existence Verify content using the current settings (required)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \Sphereon\SDK\Blockchain\Proof\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse
     */
    public function verifyUsingContent($config_name, $existence, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        list($response) = $this->verifyUsingContentWithHttpInfo($config_name, $existence, $request_id, $base64_secret, $supplied_signature, $key_id);
        return $response;
    }

    /**
     * Operation verifyUsingContentWithHttpInfo
     *
     * Verify content
     *
     * @param  string $config_name The configName for this operation (required)
     * @param  \Sphereon\SDK\Blockchain\Proof\Model\ContentRequest $existence Verify content using the current settings (required)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \Sphereon\SDK\Blockchain\Proof\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function verifyUsingContentWithHttpInfo($config_name, $existence, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        $returnType = '\Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse';
        $request = $this->verifyUsingContentRequest($config_name, $existence, $request_id, $base64_secret, $supplied_signature, $key_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sphereon\SDK\Blockchain\Proof\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation verifyUsingContentAsync
     *
     * Verify content
     *
     * @param  string $config_name The configName for this operation (required)
     * @param  \Sphereon\SDK\Blockchain\Proof\Model\ContentRequest $existence Verify content using the current settings (required)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyUsingContentAsync($config_name, $existence, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        return $this->verifyUsingContentAsyncWithHttpInfo($config_name, $existence, $request_id, $base64_secret, $supplied_signature, $key_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation verifyUsingContentAsyncWithHttpInfo
     *
     * Verify content
     *
     * @param  string $config_name The configName for this operation (required)
     * @param  \Sphereon\SDK\Blockchain\Proof\Model\ContentRequest $existence Verify content using the current settings (required)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyUsingContentAsyncWithHttpInfo($config_name, $existence, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        $returnType = '\Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse';
        $request = $this->verifyUsingContentRequest($config_name, $existence, $request_id, $base64_secret, $supplied_signature, $key_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'verifyUsingContent'
     *
     * @param  string $config_name The configName for this operation (required)
     * @param  \Sphereon\SDK\Blockchain\Proof\Model\ContentRequest $existence Verify content using the current settings (required)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function verifyUsingContentRequest($config_name, $existence, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        // verify the required parameter 'config_name' is set
        if ($config_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_name when calling verifyUsingContent'
            );
        }
        // verify the required parameter 'existence' is set
        if ($existence === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $existence when calling verifyUsingContent'
            );
        }

        $resourcePath = '/existence/{configName}/content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['requestId'] = ObjectSerializer::toHeaderValue($request_id);
        }
        // header params
        if ($base64_secret !== null) {
            $headerParams['base64Secret'] = ObjectSerializer::toHeaderValue($base64_secret);
        }
        // header params
        if ($supplied_signature !== null) {
            $headerParams['suppliedSignature'] = ObjectSerializer::toHeaderValue($supplied_signature);
        }
        // header params
        if ($key_id !== null) {
            $headerParams['keyId'] = ObjectSerializer::toHeaderValue($key_id);
        }

        // path params
        if ($config_name !== null) {
            $resourcePath = str_replace(
                '{' . 'configName' . '}',
                ObjectSerializer::toPathValue($config_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($existence)) {
            $_tempBody = $existence;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json;charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json;charset=UTF-8'],
                ['application/json;charset=UTF-8']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyUsingLocation
     *
     * Verify hash using the Storage API
     *
     * @param  string $config_name The context for this operation (required)
     * @param  \Sphereon\SDK\Blockchain\Proof\Model\StreamLocation $stream_location The stream location on storage (required)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \Sphereon\SDK\Blockchain\Proof\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse
     */
    public function verifyUsingLocation($config_name, $stream_location, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        list($response) = $this->verifyUsingLocationWithHttpInfo($config_name, $stream_location, $request_id, $base64_secret, $supplied_signature, $key_id);
        return $response;
    }

    /**
     * Operation verifyUsingLocationWithHttpInfo
     *
     * Verify hash using the Storage API
     *
     * @param  string $config_name The context for this operation (required)
     * @param  \Sphereon\SDK\Blockchain\Proof\Model\StreamLocation $stream_location The stream location on storage (required)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \Sphereon\SDK\Blockchain\Proof\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function verifyUsingLocationWithHttpInfo($config_name, $stream_location, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        $returnType = '\Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse';
        $request = $this->verifyUsingLocationRequest($config_name, $stream_location, $request_id, $base64_secret, $supplied_signature, $key_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sphereon\SDK\Blockchain\Proof\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation verifyUsingLocationAsync
     *
     * Verify hash using the Storage API
     *
     * @param  string $config_name The context for this operation (required)
     * @param  \Sphereon\SDK\Blockchain\Proof\Model\StreamLocation $stream_location The stream location on storage (required)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyUsingLocationAsync($config_name, $stream_location, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        return $this->verifyUsingLocationAsyncWithHttpInfo($config_name, $stream_location, $request_id, $base64_secret, $supplied_signature, $key_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation verifyUsingLocationAsyncWithHttpInfo
     *
     * Verify hash using the Storage API
     *
     * @param  string $config_name The context for this operation (required)
     * @param  \Sphereon\SDK\Blockchain\Proof\Model\StreamLocation $stream_location The stream location on storage (required)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyUsingLocationAsyncWithHttpInfo($config_name, $stream_location, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        $returnType = '\Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse';
        $request = $this->verifyUsingLocationRequest($config_name, $stream_location, $request_id, $base64_secret, $supplied_signature, $key_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'verifyUsingLocation'
     *
     * @param  string $config_name The context for this operation (required)
     * @param  \Sphereon\SDK\Blockchain\Proof\Model\StreamLocation $stream_location The stream location on storage (required)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function verifyUsingLocationRequest($config_name, $stream_location, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        // verify the required parameter 'config_name' is set
        if ($config_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_name when calling verifyUsingLocation'
            );
        }
        // verify the required parameter 'stream_location' is set
        if ($stream_location === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_location when calling verifyUsingLocation'
            );
        }

        $resourcePath = '/existence/{configName}/streams/location';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['requestId'] = ObjectSerializer::toHeaderValue($request_id);
        }
        // header params
        if ($base64_secret !== null) {
            $headerParams['base64Secret'] = ObjectSerializer::toHeaderValue($base64_secret);
        }
        // header params
        if ($supplied_signature !== null) {
            $headerParams['suppliedSignature'] = ObjectSerializer::toHeaderValue($supplied_signature);
        }
        // header params
        if ($key_id !== null) {
            $headerParams['keyId'] = ObjectSerializer::toHeaderValue($key_id);
        }

        // path params
        if ($config_name !== null) {
            $resourcePath = str_replace(
                '{' . 'configName' . '}',
                ObjectSerializer::toPathValue($config_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($stream_location)) {
            $_tempBody = $stream_location;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json;charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json;charset=UTF-8'],
                ['application/json;charset=UTF-8']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyUsingStream
     *
     * Verify bytestream/file hash
     *
     * @param  string $config_name The configuration name this operation (required)
     * @param  \SplFileObject $stream The binary data (not hashed). Hashing will be done on the server side. The binary data will not be stored (required)
     * @param  string $file_name Optional input file name. Needed when using bytestreams instead of filestreams (optional)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \Sphereon\SDK\Blockchain\Proof\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse
     */
    public function verifyUsingStream($config_name, $stream, $file_name = null, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        list($response) = $this->verifyUsingStreamWithHttpInfo($config_name, $stream, $file_name, $request_id, $base64_secret, $supplied_signature, $key_id);
        return $response;
    }

    /**
     * Operation verifyUsingStreamWithHttpInfo
     *
     * Verify bytestream/file hash
     *
     * @param  string $config_name The configuration name this operation (required)
     * @param  \SplFileObject $stream The binary data (not hashed). Hashing will be done on the server side. The binary data will not be stored (required)
     * @param  string $file_name Optional input file name. Needed when using bytestreams instead of filestreams (optional)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \Sphereon\SDK\Blockchain\Proof\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function verifyUsingStreamWithHttpInfo($config_name, $stream, $file_name = null, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        $returnType = '\Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse';
        $request = $this->verifyUsingStreamRequest($config_name, $stream, $file_name, $request_id, $base64_secret, $supplied_signature, $key_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sphereon\SDK\Blockchain\Proof\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation verifyUsingStreamAsync
     *
     * Verify bytestream/file hash
     *
     * @param  string $config_name The configuration name this operation (required)
     * @param  \SplFileObject $stream The binary data (not hashed). Hashing will be done on the server side. The binary data will not be stored (required)
     * @param  string $file_name Optional input file name. Needed when using bytestreams instead of filestreams (optional)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyUsingStreamAsync($config_name, $stream, $file_name = null, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        return $this->verifyUsingStreamAsyncWithHttpInfo($config_name, $stream, $file_name, $request_id, $base64_secret, $supplied_signature, $key_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation verifyUsingStreamAsyncWithHttpInfo
     *
     * Verify bytestream/file hash
     *
     * @param  string $config_name The configuration name this operation (required)
     * @param  \SplFileObject $stream The binary data (not hashed). Hashing will be done on the server side. The binary data will not be stored (required)
     * @param  string $file_name Optional input file name. Needed when using bytestreams instead of filestreams (optional)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyUsingStreamAsyncWithHttpInfo($config_name, $stream, $file_name = null, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        $returnType = '\Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse';
        $request = $this->verifyUsingStreamRequest($config_name, $stream, $file_name, $request_id, $base64_secret, $supplied_signature, $key_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'verifyUsingStream'
     *
     * @param  string $config_name The configuration name this operation (required)
     * @param  \SplFileObject $stream The binary data (not hashed). Hashing will be done on the server side. The binary data will not be stored (required)
     * @param  string $file_name Optional input file name. Needed when using bytestreams instead of filestreams (optional)
     * @param  string $request_id Optional request id (optional)
     * @param  string $base64_secret An alternate secret key in base64 format that overrides the value in your configuration. (optional)
     * @param  string $supplied_signature An alternate supplied Signature in base64 format that overrides the signature generation. (optional)
     * @param  string $key_id An alternate crypto keys API id that will be used for signature generation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function verifyUsingStreamRequest($config_name, $stream, $file_name = null, $request_id = null, $base64_secret = null, $supplied_signature = null, $key_id = null)
    {
        // verify the required parameter 'config_name' is set
        if ($config_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $config_name when calling verifyUsingStream'
            );
        }
        // verify the required parameter 'stream' is set
        if ($stream === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream when calling verifyUsingStream'
            );
        }

        $resourcePath = '/existence/{configName}/streams/multipart';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file_name !== null) {
            $queryParams['fileName'] = ObjectSerializer::toQueryValue($file_name);
        }
        // header params
        if ($request_id !== null) {
            $headerParams['requestId'] = ObjectSerializer::toHeaderValue($request_id);
        }
        // header params
        if ($base64_secret !== null) {
            $headerParams['base64Secret'] = ObjectSerializer::toHeaderValue($base64_secret);
        }
        // header params
        if ($supplied_signature !== null) {
            $headerParams['suppliedSignature'] = ObjectSerializer::toHeaderValue($supplied_signature);
        }
        // header params
        if ($key_id !== null) {
            $headerParams['keyId'] = ObjectSerializer::toHeaderValue($key_id);
        }

        // path params
        if ($config_name !== null) {
            $resourcePath = str_replace(
                '{' . 'configName' . '}',
                ObjectSerializer::toPathValue($config_name),
                $resourcePath
            );
        }

        // form params
        if ($stream !== null) {
            $multipart = true;
            $formParams['stream'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($stream), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json;charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json;charset=UTF-8'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
