<?php
/**
 * Blockchain Proof
 *
 * With the Blockchain Proof API it is easy to prove or disprove existence of data at a certain point in time. Behind the scenes it stores entries using the Factom (bitcoin), Multichain or Ethereum blockchain by means of our generic blockchain API.    The flow is generally as follows:  1. Make sure a configuration is present  2. Register content by uploading a file, some content, or providing a Stream Location from the Storage API. When you upload content you have to tell the API whether the data has already been hashed or not. If not, or when uploading a file or stream location, the API will take care of the hashing  3. Verify content by uploading a file, some content, or providing a Stream Location from the Storage API. When you upload content you have to tell the API whether the data has already been hashed or not. If not, or when uploading a file or stream location, the API will take care of the hashing. You will get back whether the content has been registered previously or not    Full API Documentation: https://docs.sphereon.com/api/blockchain-proof/0.10/html  Interactive testing: A web based test console is available in the Sphereon API Store at https://store.sphereon.com
 *
 * OpenAPI spec version: 0.10
 * Contact: dev@sphereon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

namespace Sphereon\SDK\Blockchain\Proof;

use \Sphereon\SDK\Blockchain\Proof\Api\ConfigurationApi;
use \Sphereon\SDK\Blockchain\Proof\Api\RegistrationApi;
use \Sphereon\SDK\Blockchain\Proof\Api\VerificationApi;
use \Sphereon\SDK\Blockchain\Proof\ApiException;
use \Sphereon\SDK\Blockchain\Proof\ObjectSerializer;
use \Sphereon\SDK\Blockchain\Proof\Model\ContentRequest;
use \Sphereon\SDK\Blockchain\Proof\Model\ChainSettings;
use \Sphereon\SDK\Blockchain\Proof\Model\Configuration;
use \Sphereon\SDK\Blockchain\Proof\Model\ConfigurationResponse;
use \Sphereon\SDK\Blockchain\Proof\Model\CreateConfigurationRequest;
use \Sphereon\SDK\Blockchain\Proof\Model\RegisterContentResponse;
use \Sphereon\SDK\Blockchain\Proof\Model\VerifyContentResponse;

/**
 * VerificationApiTest Class Doc Comment
 *
 * @category Class
 * @package  Sphereon\SDK\Blockchain\Proof
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class BlockchainProofApiTest extends \PHPUnit_Framework_TestCase
{
	private static $configuration_api_instance;
	private static $registration_api_instance;
	private static $verification_api_instance;
	
	private $context = "multichain";
	
	private static $config_name;
	private static $config_id;
	private static $proof_chain_id;
	
	private static $content;

    /**
     * Setup before running any test cases
     */
    public static function setUpBeforeClass()
    {
		$config = \Sphereon\SDK\Blockchain\Proof\Configuration::getDefaultConfiguration()->setAccessToken('344d7ac8-d82f-3be0-b81b-488723a7c306');

		self::$configuration_api_instance = new ConfigurationApi(
			// If you want use custom http client, pass your client which implements `GuzzleHttp\ClientInterface`.
			// This is optional, `GuzzleHttp\Client` will be used as default.
			new \GuzzleHttp\Client(),
			$config
		);
		self::$registration_api_instance = new RegistrationApi(
			// If you want use custom http client, pass your client which implements `GuzzleHttp\ClientInterface`.
			// This is optional, `GuzzleHttp\Client` will be used as default.
			new \GuzzleHttp\Client(),
			$config
		);
		self::$verification_api_instance = new VerificationApi(
			// If you want use custom http client, pass your client which implements `GuzzleHttp\ClientInterface`.
			// This is optional, `GuzzleHttp\Client` will be used as default.
			new \GuzzleHttp\Client(),
			$config
		);
    }

    /**
     * Setup before running each test case
     */
    public function setUp()
    {
    }

    /**
     * Clean up after running each test case
     */
    public function tearDown()
    {
    }

    /**
     * Clean up after running all test cases
     */
    public static function tearDownAfterClass()
    {
    }
	
    /**
     * Test case for createConfiguration
     *
     * Create a new configuration.
     *
     */
    public function testCreateConfiguration()
    {
		self::$config_name = sprintf("blockchain-proof-unit-test-config-%s", uniqid());

		$content_registration_chain_types = array(ChainSettings::CONTENT_REGISTRATION_CHAIN_TYPES_SINGLE_PROOF_CHAIN, ChainSettings::CONTENT_REGISTRATION_CHAIN_TYPES_PER_HASH_PROOF_CHAIN);
		
		$chain_settings = new ChainSettings(); 
		$chain_settings->setVersion(ChainSettings::VERSION_1);
		$chain_settings->setHashAlgorithm(ChainSettings::HASH_ALGORITHM__256);
		$chain_settings->setContentRegistrationChainTypes($content_registration_chain_types);	
		
		$request = new CreateConfigurationRequest(); 
		$request->setName(self::$config_name);
		$request->setContext($this->context);
		$request->setAccessMode(Configuration::ACCESS_MODE__PRIVATE);
		$request->setInitialSettings($chain_settings);
		
		print_r($request);
		
		$result = self::$configuration_api_instance->createConfiguration($request);

		print_r($result);		

		$this->assertInstanceOf(ConfigurationResponse::class, $result);
		
		$result_configuration = $result->getConfiguration();
		$this->assertNotNull($result_configuration);
		$this->assertNotNull($result_configuration->getContext());
		$this->assertNotNull($result_configuration->getChainSettings());
		$this->assertNotNull($result_configuration->getSingleProofChain());
		$this->assertNotNull($result_configuration->getChainSettings()->getSingleProofChain());
		$this->assertNotNull($result_configuration->getChainSettings()->getHashAlgorithm());
		
		self::$config_id = $result_configuration->getId();
		self::$proof_chain_id = $result_configuration->getSingleProofChain()->getChainId();
    }

    /**
     * Test case for getConfiguration
     *
     * Get configuration.
     *
	 * @depends testCreateConfiguration
     */
    public function testGetConfiguration()
    {
		$result = self::$configuration_api_instance->getConfiguration(self::$config_name);
		
		$this->assertInstanceOf(ConfigurationResponse::class, $result);
		
		$result_configuration = $result->getConfiguration();
		$this->assertNotNull($result_configuration);
		$this->assertNotNull($result_configuration->getContext());
		$this->assertNotNull($result_configuration->getChainSettings());
		$this->assertNotNull($result_configuration->getSingleProofChain());
		$this->assertNotNull($result_configuration->getChainSettings()->getSingleProofChain());
		$this->assertNotNull($result_configuration->getChainSettings()->getHashAlgorithm());
		
        $this->assertEquals(self::$config_id, $result_configuration->getId());
        $this->assertEquals(self::$proof_chain_id, $result_configuration->getSingleProofChain()->getChainId());
    }
	
    /**
     * Test case for registerUsingStream
     *
     * Register bytestream/file hash.
     *
	 * @depends testGetConfiguration
     */
    public function testRegisterUsingStream()
    {
		$stream = "lorem-ipsum.pdf"; // \SplFileObject | The binary data (not hashed). Hashing will be done on the server side. The binary data will not be stored
		$file_name = "lorem-ipsum.pdf"; // string | Optional input file name. Needed when using bytestreams instead of filestreams
		$request_id = uniqid(); // string | Optional request id

		$result = self::$registration_api_instance->registerUsingStream(self::$config_name, $stream, $file_name, $request_id, null, null, null);

		$this->assertInstanceOf(RegisterContentResponse::class, $result);
		$this->assertNotNull($result);
		$this->assertNotNull($result->getSingleProofChain());
		$this->assertEquals($request_id, $result->getRequestId());
    }

    /**
     * Test case for verifyUsingStream
     *
     * Verify bytestream/file hash.
     *
	 * @depends testRegisterUsingStream
     */
    public function testVerifyUsingStream()
    {
		sleep(15); // wait until the file is registerd on the blockchain
		
		$stream = "lorem-ipsum.pdf"; // \SplFileObject | The binary data (not hashed). Hashing will be done on the server side. The binary data will not be stored
		$file_name = "lorem-ipsum.pdf"; // string | Optional input file name. Needed when using bytestreams instead of filestreams
		$request_id = uniqid(); // string | Optional request id

	    $result = self::$verification_api_instance->verifyUsingStream(self::$config_name, $stream, $file_name, $request_id, null, null, null);

		$this->assertInstanceOf(VerifyContentResponse::class, $result);
		$this->assertNotNull($result);
		$this->assertNotNull($result->getSingleProofChain());
		$this->assertEquals($request_id, $result->getRequestId());
		$this->assertTrue($result->getRegistrationState() == VerifyContentResponse::REGISTRATION_STATE_REGISTERED || $result->getRegistrationState() == VerifyContentResponse::REGISTRATION_STATE_PENDING);

	}
}
